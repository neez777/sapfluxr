graph TB
    Start([Raw SFM1x Data]) --> Import[Import Data<br/>read_heat_pulse_data<br/>Extract Temps & Diagnostics]
    Import --> ClockDrift{Clock Drift<br/>Detected?}
    ClockDrift -->|Yes| FixDrift[Fix Clock Drift<br/>fix_clock_drift<br/>Linear interpolation from calibration point]
    ClockDrift -->|No| Setup
    FixDrift --> Setup[Setup Parameters<br/>thermal_diffusivity, probe_spacing,<br/>heat_pulse_duration, windows]
    Setup --> Baseline[Calculate Pre-Pulse Baseline<br/>Mean T during 0-30s]
    Baseline --> DeltaT[Calculate delta_T<br/>T - Baseline for each probe]
    DeltaT --> Ratios[Calculate Basic Ratios<br/>delta_T_downstream/delta_T_upstream for each pair]

    Ratios --> Methods{Select Method<br/>calc_heat_pulse_velocity}

    Methods -->|HRM| HRM1[Extract Window 60-100s]
    HRM1 --> HRM2[Average Ratios in Window]
    HRM2 --> HRM3[Vh = thermal_diffusivity/probe_spacing × ln ratio × 3600]
    HRM3 --> HRM4[Calculate Peclet Number<br/>Pe = Vh × x / D × 3600]
    HRM4 --> HRMOut[HRM Velocity + Pe<br/>CALC_ quality flags applied]

    Methods -->|MHR| MHR1[Find delta_T_max for each probe]
    MHR1 --> MHR2[Calculate max ratio<br/>delta_T_downstream_max/delta_T_upstream_max]
    MHR2 --> MHR3[Vh = thermal_diffusivity/probe_spacing × ln max_ratio × 3600]
    MHR3 --> MHROut[MHR Velocity<br/>CALC_ quality flags applied]

    Methods -->|HRMX| HRMX1[Extract Pre-Max Values<br/>Only rising phase]
    HRMX1 --> HRMX2[Define Window<br/>hrmx_lower_threshold × delta_T_max to<br/>hrmx_upper_threshold × delta_T_max]
    HRMX2 --> HRMX3[Filter values in window]
    HRMX3 --> HRMXChoice{HRMX Variant?}
    HRMXChoice -->|HRMXa| HRMXa[Average ratios within window]
    HRMXChoice -->|HRMXb| HRMXb[Ratio of averaged temps]
    HRMXa --> HRMX4[Vh = thermal_diffusivity/probe_spacing × ln ratio × 3600]
    HRMXb --> HRMX4
    HRMX4 --> HRMXOut[HRMX Velocity<br/>CALC_ quality flags applied]

    Methods -->|Tmax Cohen| TC1[Find time_to_max_temp]
    TC1 --> TC2[Vh = √ probe_spacing²-4×thermal_diffusivity×time_to_max / time_to_max]
    TC2 --> TCOut[Tmax_Coh Velocity<br/>CALC_ quality flags applied]

    Methods -->|Tmax Kluit| TK1[Find time_to_max_temp]
    TK1 --> TK2[Include heat_pulse_duration]
    TK2 --> TK3[Vh with finite pulse correction]
    TK3 --> TKOut[Tmax_Klu Velocity<br/>CALC_ quality flags applied]

    HRMOut --> QualityControl
    MHROut --> QualityControl
    HRMXOut --> QualityControl
    TCOut --> QualityControl
    TKOut --> QualityControl

    QualityControl[Quality Control<br/>flag_vh_quality<br/>Apply DATA_ flags] --> QC1[Detect Missing Pulses<br/>DATA_MISSING]
    QC1 --> QC2[Detect Illogical Values<br/>DATA_ILLOGICAL]
    QC2 --> QC3[Detect Statistical Outliers<br/>Rolling Median + Rate of Change<br/>DATA_OUTLIER]
    QC3 --> QC4[Detect Cross-Sensor Anomalies<br/>Negative Flows<br/>DATA_SUSPECT]
    QC4 --> QCOut[Flagged Results<br/>Two-tier quality flags:<br/>CALC_ + DATA_]

    QCOut --> PostProcess{Apply Post-Processing?}
    PostProcess -->|Yes: sDMA| SDMA[Selectable DMA<br/>apply_sdma_processing<br/>Secondary method choice]
    PostProcess -->|No| Correct

    SDMA --> SDMA1{Calculate Peclet Number<br/>From HRM results}
    SDMA1 --> SDMA2{Pe < 1.0?}
    SDMA2 -->|Yes: Low Flow| SDMA3[Use HRM]
    SDMA2 -->|No: High Flow| SDMA4[Use Secondary Method<br/>MHR, Tmax_Klu, Tmax_Coh,<br/>HRMXa, or HRMXb]
    SDMA3 --> SDMAOut[sDMA Velocity<br/>with selected_method column]
    SDMA4 --> SDMAOut

    SDMAOut --> DataStructure
    DataStructure[Initialize Hybrid Structure<br/>Vh_cm_hr_raw preserved<br/>Vh_cm_hr = current pointer] --> CorrectionPath{Choose<br/>Correction Path}

    CorrectionPath -->|Path A: Universal| ZeroFlow[Zero-Flow Offset Correction<br/>apply_zero_flow_offset<br/>Define zero-flow periods<br/>Calculate mean offset]
    CorrectionPath -->|Path B: HRM-Specific| SpaceCorr

    ZeroFlow --> ZFValidate[Create Vh_cm_hr_zf<br/>Update pointer<br/>Store offset results]
    ZFValidate --> ZFWound{Apply Wound<br/>Correction?}

    SpaceCorr[Spacing Correction Workflow<br/>apply_spacing_correction_workflow<br/>HRM only] --> SCDetect[Detect Zero-Flow Offset<br/>From defined periods]
    SCDetect --> SCValidate{Validate Offset<br/>≤ Physical Limit?}
    SCValidate -->|Yes: Valid| SCApply[Apply Burgess Correction<br/>Lookup coefficients B, C<br/>Create Vh_cm_hr_sc]
    SCValidate -->|No: Invalid| SCFallback[Fallback to Linear Offset<br/>Create Vh_cm_hr_zf<br/>Offset > max physical]

    SCApply --> SCWound{Apply Wound<br/>Correction?}
    SCFallback --> ZFWound

    ZFWound -->|Yes| ZFWoundCorr[Wound Correction<br/>apply_wound_correction<br/>Input: Vh_cm_hr_zf<br/>Output: Vh_cm_hr_zf_wc]
    ZFWound -->|No| Convert

    SCWound -->|Yes| SCWoundCorr[Wound Correction<br/>apply_wound_correction<br/>Input: Vh_cm_hr_sc<br/>Output: Vh_cm_hr_sc_wc]
    SCWound -->|No| Convert

    ZFWoundCorr --> WCUpdate1[Update pointer<br/>Vh_cm_hr → Vh_cm_hr_zf_wc<br/>Track correction history]
    SCWoundCorr --> WCUpdate2[Update pointer<br/>Vh_cm_hr → Vh_cm_hr_sc_wc<br/>Track correction history]

    WCUpdate1 --> Convert
    WCUpdate2 --> Convert

    Convert[Convert to Sap Flux Density<br/>sap_flux_density = f moisture_content, Vh<br/>Uses current Vh_cm_hr pointer]

    Convert --> Output[(Output Results<br/>All correction stages preserved:<br/>Vh_cm_hr_raw, Vh_cm_hr_zf, Vh_cm_hr_sc,<br/>Vh_cm_hr_*_wc, Vh_cm_hr current,<br/>metadata attributes)]

    style Start fill:#e1f5ff
    style Output fill:#ffe1e1
    style Methods fill:#fff4e1
    style SDMA2 fill:#fff4e1
    style HRMXChoice fill:#fff4e1
    style ClockDrift fill:#ffe1ff
    style QualityControl fill:#ffe1e1
    style PostProcess fill:#fff4e1
    style CorrectionPath fill:#fff4e1
    style SCValidate fill:#fff4e1
    style ZFWound fill:#e1ffe1
    style SCWound fill:#e1ffe1
    style DataStructure fill:#e1ffe1
