---
title: "Spacing Correction Methods in sapfluxr"
author: "sapfluxr package"
date: "`r Sys.Date()`"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Spacing Correction Methods in sapfluxr}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.width = 7,
  fig.height = 5
)
```

## Introduction

Heat pulse velocity (HPV) sensors measure sap flow by detecting temperature changes at upstream and downstream thermistor probes after a heat pulse is released. The accuracy of velocity calculations depends critically on knowing the exact spacing between probes. However, this spacing changes over time as trees:

- **Swell** with water uptake (increasing spacing)
- **Shrink** during drought (decreasing spacing)
- **Grow** radially (both swelling and cambial growth)

**The problem:** Velocity calculations assume constant probe spacing, but actual spacing varies by ±10-30% seasonally. This creates systematic velocity biases of 10-50% depending on flow rate.

**The solution:** Use zero-flow periods to estimate actual probe spacing, then apply the Burgess correction (Burgess et al. 2001) to adjust velocity calculations.

This vignette demonstrates the **unified spacing correction interface** in sapfluxr, which provides four methods for identifying and correcting spacing errors:

1. **PELT** - Automatic changepoint detection
2. **Manual** - User-specified changepoint dates
3. **VPD** - Environmental suitability based on low vapor pressure deficit
4. **Heartwood** - Continuous correction using inner sensor as zero-flow reference

## Installation and Setup

```{r load-package, eval=FALSE}
library(sapfluxr)
library(ggplot2)  # For visualisation
```

```{r load-data, eval=FALSE}
# Load example data
hp_raw <- read_heat_pulse_data(
  "path/to/your/data.txt",
  trim_incomplete_days = TRUE
)

# Load wood properties
wood <- load_wood_properties("path/to/your/wood.yaml")
wood <- calculate_wood_properties(wood)

# Load probe configuration
probe <- load_probe_config("symmetrical")

# Calculate heat pulse velocity
vh_results <- calc_heat_pulse_velocity(
  hp_raw,
  methods = c("HRM", "MHR", "HRMXb"),
  wood_properties = wood
)
```

## The Unified Interface

All spacing correction methods use the same function with a unified interface:

```{r unified-interface, eval=FALSE}
result <- apply_spacing_correction(
  vh_data = vh_results,
  method = "pelt",              # or "manual", "vpd", "heartwood"
  hpv_method = "HRM",
  wood_properties = wood,
  probe_config = probe,
  verbose = TRUE
)
```

The function returns a consistent structure regardless of method:

```{r return-structure, eval=FALSE}
# Corrected velocity data
vh_corrected <- result$vh_corrected

# Method used
result$method_used

# Detected changepoints (NULL for heartwood method)
result$changepoints

# Segment information (NULL for heartwood method)
result$segments

# Method-specific correction details
result$correction_info

# Metadata (parameters, timing, etc.)
result$metadata
```

## Method 1: PELT (Automatic Detection)

The **PELT** (Pruned Exact Linear Time) method automatically detects changepoints in the daily minimum velocity timeseries. This is the **recommended starting point** for most analyses.

### When to Use PELT

- ✅ First-time analysis when changepoints are unknown
- ✅ Objective, reproducible changepoint identification
- ✅ Datasets with clear transitions between flow regimes
- ✅ At least 7-14 days of data available

### Basic Usage

```{r pelt-basic, eval=FALSE}
result_pelt <- apply_spacing_correction(
  vh_data = vh_results,
  method = "pelt",
  hpv_method = "HRM",
  wood_properties = wood
)

# Review detected changepoints
print(result_pelt$changepoints)
print(result_pelt$segments)
```

### Parameter Tuning

The PELT algorithm has two key parameters:

#### 1. Penalty Parameter

Controls the trade-off between model fit and model complexity. Stricter penalties detect fewer changepoints.

```{r pelt-penalty, eval=FALSE}
# Conservative (fewer changepoints)
result_bic <- apply_spacing_correction(
  vh_data = vh_results,
  method = "pelt",
  wood_properties = wood,
  penalty = "BIC"        # Bayesian Information Criterion
)

# Moderate (recommended default)
result_mbic <- apply_spacing_correction(
  vh_data = vh_results,
  method = "pelt",
  wood_properties = wood,
  penalty = "MBIC"       # Modified BIC (default)
)

# Permissive (more changepoints)
result_aic <- apply_spacing_correction(
  vh_data = vh_results,
  method = "pelt",
  wood_properties = wood,
  penalty = "AIC"        # Akaike Information Criterion
)

# Compare number of changepoints
cat("BIC:", length(result_bic$changepoints), "\n")
cat("MBIC:", length(result_mbic$changepoints), "\n")
cat("AIC:", length(result_aic$changepoints), "\n")
```

**Guidance:**
- Use **BIC** for conservative detection (fewer changepoints, lower false positive rate)
- Use **MBIC** (default) for balanced detection
- Use **AIC** when you suspect many small changes occurred
- Use **numeric value** for custom penalty (higher = fewer changepoints)

#### 2. Minimum Segment Length

Prevents detection of very short segments that likely represent noise rather than real spacing changes.

```{r pelt-segment-length, eval=FALSE}
# Longer segments (more conservative)
result_long <- apply_spacing_correction(
  vh_data = vh_results,
  method = "pelt",
  wood_properties = wood,
  min_segment_days = 14         # Require 14+ days per segment
)

# Default
result_default <- apply_spacing_correction(
  vh_data = vh_results,
  method = "pelt",
  wood_properties = wood,
  min_segment_days = 7          # Default: 7 days
)

# Shorter segments (more sensitive)
result_short <- apply_spacing_correction(
  vh_data = vh_results,
  method = "pelt",
  wood_properties = wood,
  min_segment_days = 3          # Allow 3+ days per segment
)
```

**Guidance:**
- Use **14 days** for very noisy data or when you expect infrequent spacing changes
- Use **7 days** (default) for typical seasonal monitoring
- Use **3-5 days** for high-frequency sampling or when you expect frequent changes

### Visualising Results

```{r pelt-visualise, eval=FALSE}
# Interactive plot with changepoints
plot_changepoints_interactive(
  daily_min = result_pelt$correction_info$daily_min,
  changepoints = result_pelt$changepoints,
  segments = result_pelt$segments,
  title = "Detected Changepoints (PELT Method)"
)

# Compare before and after correction
plot_vh_timeseries(result_pelt$vh_corrected, sensor_position = "outer")
```

### Assessing Correction Impact

```{r pelt-impact, eval=FALSE}
# Calculate mean velocities before and after
hrm_before <- vh_results[vh_results$method == "HRM" &
                         vh_results$sensor_position == "outer", ]
hrm_after <- result_pelt$vh_corrected[
  result_pelt$vh_corrected$method == "HRM" &
  result_pelt$vh_corrected$sensor_position == "outer", ]

mean_before <- mean(hrm_before$Vh_cm_hr, na.rm = TRUE)
mean_after <- mean(hrm_after$Vh_cm_hr, na.rm = TRUE)
change_pct <- ((mean_after - mean_before) / mean_before) * 100

cat("Mean Vh before correction:", round(mean_before, 3), "cm/hr\n")
cat("Mean Vh after correction:", round(mean_after, 3), "cm/hr\n")
cat("Change:", round(change_pct, 1), "%\n")
```

## Method 2: Manual Specification

The **manual** method allows you to specify exact changepoint dates based on field observations, previous analyses, or domain knowledge.

### When to Use Manual

- ✅ Known dates when spacing changed (field observations)
- ✅ Refining automatic detection results
- ✅ Specific events: frost, drought recovery, sensor maintenance
- ✅ Testing sensitivity to changepoint timing

### Basic Usage

```{r manual-basic, eval=FALSE}
result_manual <- apply_spacing_correction(
  vh_data = vh_results,
  method = "manual",
  hpv_method = "HRM",
  wood_properties = wood,
  manual_changepoints = c("2024-03-15", "2024-06-10")
)
```

### Using PELT Results as Starting Point

A common workflow is to use PELT for initial detection, then refine manually:

```{r manual-refine, eval=FALSE}
# Step 1: Run PELT
result_pelt <- apply_spacing_correction(
  vh_data = vh_results,
  method = "pelt",
  wood_properties = wood
)

# Step 2: Review detected dates
print(result_pelt$changepoints)

# Step 3: Plot to assess visually
plot_changepoints_interactive(
  daily_min = result_pelt$correction_info$daily_min,
  changepoints = result_pelt$changepoints,
  segments = result_pelt$segments
)

# Step 4: Refine manually if needed
# E.g., remove spurious changepoint, add missed one
manual_dates <- as.character(result_pelt$changepoints[c(1, 3, 5)])  # Keep 1st, 3rd, 5th
manual_dates <- c(manual_dates, "2024-07-20")  # Add missed date

result_manual <- apply_spacing_correction(
  vh_data = vh_results,
  method = "manual",
  wood_properties = wood,
  manual_changepoints = manual_dates
)
```

### Manual Baseline Override

If you know the actual zero-flow velocities for specific segments (e.g., from controlled experiments), you can specify them directly:

```{r manual-baseline, eval=FALSE}
# Specify baselines for outer sensor
baseline_outer <- list(
  "1" = 0.82,   # Segment 1: baseline = 0.82 cm/hr
  "2" = 1.50,   # Segment 2: baseline = 1.50 cm/hr
  "3" = 0.65    # Segment 3: baseline = 0.65 cm/hr
)

# Specify baselines for inner sensor (optional, separate from outer)
baseline_inner <- list(
  "1" = 1.20,
  "2" = 1.80,
  "3" = 0.90
)

result_manual <- apply_spacing_correction(
  vh_data = vh_results,
  method = "manual",
  wood_properties = wood,
  manual_changepoints = c("2024-03-15", "2024-06-10"),
  baseline_overrides_outer = baseline_outer,
  baseline_overrides_inner = baseline_inner
)
```

**When to override baselines:**
- You have independent measurements of zero flow
- Field observations suggest calculated baselines are incorrect
- Sensor malfunction affects baseline detection
- Extreme events (freeze-thaw, severe drought) create unreliable automatic baselines

## Method 3: VPD-Based Detection

The **VPD** method identifies correction periods based on environmental conditions. Low vapor pressure deficit (VPD) periods typically indicate minimal transpiration and near-zero sap flow, making them suitable for baseline estimation.

### When to Use VPD

- ✅ Strong diurnal VPD patterns at your site
- ✅ Sap flow is primarily controlled by atmospheric demand
- ✅ Validating PELT results against environmental conditions
- ✅ Weather data available with VPD or humidity + temperature

### Requirements

VPD method requires weather data with either:

1. **Direct VPD** column (in kPa), or
2. **Relative humidity** (%) and **temperature** (°C) for VPD calculation

```{r vpd-weather-data, eval=FALSE}
# Load weather data
weather <- read.csv("path/to/weather_data.csv")

# Expected columns:
#   - datetime (POSIXct or character)
#   - VPD_kPa (numeric), OR
#   - RH (numeric, 0-100) AND Temp_C (numeric)

# If VPD not present, calculate it
if (!"VPD_kPa" %in% names(weather)) {
  weather$VPD_kPa <- calculate_vpd(
    temperature_C = weather$Temp_C,
    relative_humidity = weather$RH
  )
}
```

### Basic Usage

```{r vpd-basic, eval=FALSE}
result_vpd <- apply_spacing_correction(
  vh_data = vh_results,
  method = "vpd",
  hpv_method = "HRM",
  wood_properties = wood,
  weather_data = weather,
  vpd_threshold = 0.5        # kPa
)

# Review detected changepoints
print(result_vpd$changepoints)
```

### VPD Threshold Selection

The VPD threshold determines which periods are considered "low VPD" and suitable for baseline estimation.

```{r vpd-thresholds, eval=FALSE}
# Conservative (very low VPD only)
result_vpd_conservative <- apply_spacing_correction(
  vh_data = vh_results,
  method = "vpd",
  wood_properties = wood,
  weather_data = weather,
  vpd_threshold = 0.3        # kPa - early morning/night only
)

# Moderate (recommended default)
result_vpd_moderate <- apply_spacing_correction(
  vh_data = vh_results,
  method = "vpd",
  wood_properties = wood,
  weather_data = weather,
  vpd_threshold = 0.5        # kPa - typical low-demand periods
)

# Permissive (higher VPD allowed)
result_vpd_permissive <- apply_spacing_correction(
  vh_data = vh_results,
  method = "vpd",
  wood_properties = wood,
  weather_data = weather,
  vpd_threshold = 0.8        # kPa - includes moderate VPD
)
```

**Guidance for threshold selection:**

| VPD Threshold | Conditions | Use When |
|---------------|------------|----------|
| 0.2-0.3 kPa | Very low atmospheric demand | Conservative baseline, humid sites |
| 0.4-0.6 kPa | Low to moderate demand | Balanced approach (default) |
| 0.7-1.0 kPa | Moderate demand | Arid sites, sparse low-VPD periods |

### Additional VPD Parameters

```{r vpd-advanced, eval=FALSE}
result_vpd <- apply_spacing_correction(
  vh_data = vh_results,
  method = "vpd",
  wood_properties = wood,
  weather_data = weather,
  vpd_threshold = 0.5,
  min_suitable_days = 3,     # Require 3+ consecutive low-VPD days
  max_gap_days = 2           # Bridge gaps ≤ 2 days between low-VPD periods
)
```

### Comparing VPD vs PELT

```{r vpd-compare, eval=FALSE}
# Run both methods
result_pelt <- apply_spacing_correction(vh_data = vh_results, method = "pelt",
                                        wood_properties = wood)
result_vpd <- apply_spacing_correction(vh_data = vh_results, method = "vpd",
                                       wood_properties = wood, weather_data = weather)

# Compare detected changepoints
cat("PELT changepoints:", length(result_pelt$changepoints), "\n")
cat("VPD changepoints:", length(result_vpd$changepoints), "\n")

# Check for overlap (within 3 days)
for (vpd_date in result_vpd$changepoints) {
  pelt_dates <- result_pelt$changepoints
  time_diffs <- abs(as.numeric(vpd_date - pelt_dates))
  if (any(time_diffs <= 3)) {
    closest <- pelt_dates[which.min(time_diffs)]
    cat("VPD", as.character(vpd_date), "≈ PELT", as.character(closest),
        "(", min(time_diffs), "days apart)\n")
  }
}
```

**Interpretation:**
- **High overlap** (dates within 3 days): Both methods agree, high confidence in changepoints
- **Moderate overlap**: Methods detect similar patterns but with timing differences
- **Low overlap**: Methods diverge substantially - investigate data quality and assumptions

## Method 4: Heartwood Reference

The **heartwood** method uses the inner sensor as a continuous zero-flow reference, provided it is deep enough in the heartwood (non-conductive xylem).

### When to Use Heartwood

- ✅ Inner sensor depth > sapwood depth + safety margin (≥0.5 cm)
- ✅ Long-term continuous monitoring
- ✅ Avoiding segmentation artifacts at changepoint boundaries
- ✅ Real-time correction as data arrives

### Checking Availability

First verify that heartwood reference is available:

```{r heartwood-check, eval=FALSE}
# Check if heartwood reference can be used
heartwood_check <- check_heartwood_reference_available(
  vh_data = vh_results,
  wood_properties = wood,
  probe_config = probe
)

cat("Heartwood reference available:", heartwood_check$available, "\n")
cat("Reason:", heartwood_check$reason, "\n")

# Review depths
cat("\nInner sensor depth:", probe$sensor_depths$inner_cm, "cm\n")
cat("Sapwood depth:", wood$sapwood_depth_cm, "cm\n")
cat("Margin:", probe$sensor_depths$inner_cm - wood$sapwood_depth_cm, "cm\n")
```

### Basic Usage

```{r heartwood-basic, eval=FALSE}
if (heartwood_check$available) {
  result_heartwood <- apply_spacing_correction(
    vh_data = vh_results,
    method = "heartwood",
    hpv_method = "HRM",
    wood_properties = wood,
    probe_config = probe
  )

  # No changepoints with heartwood method (continuous correction)
  cat("Method:", result_heartwood$method_used, "\n")
  cat("Changepoints:", result_heartwood$changepoints, "\n")  # NULL
  cat("Segments:", result_heartwood$segments, "\n")          # NULL
}
```

### Advanced Parameters

```{r heartwood-advanced, eval=FALSE}
result_heartwood <- apply_spacing_correction(
  vh_data = vh_results,
  method = "heartwood",
  wood_properties = wood,
  probe_config = probe,
  smoothing_window = 24,      # Hours for moving average of heartwood reference
  min_heartwood_depth = 0.5   # cm beyond sapwood depth required
)
```

### Comparing Heartwood vs PELT

```{r heartwood-compare, eval=FALSE}
# Run both methods
result_pelt <- apply_spacing_correction(vh_data = vh_results, method = "pelt",
                                        wood_properties = wood)
result_heartwood <- apply_spacing_correction(vh_data = vh_results, method = "heartwood",
                                             wood_properties = wood, probe_config = probe)

# Extract corrected data
hrm_pelt <- result_pelt$vh_corrected[
  result_pelt$vh_corrected$method == "HRM" &
  result_pelt$vh_corrected$sensor_position == "outer", ]

hrm_heartwood <- result_heartwood$vh_corrected[
  result_heartwood$vh_corrected$method == "HRM" &
  result_heartwood$vh_corrected$sensor_position == "outer", ]

# Compare mean velocities
cat("PELT mean Vh:", round(mean(hrm_pelt$Vh_cm_hr, na.rm = TRUE), 3), "cm/hr\n")
cat("Heartwood mean Vh:", round(mean(hrm_heartwood$Vh_cm_hr, na.rm = TRUE), 3), "cm/hr\n")

# Key difference: Heartwood is continuous, PELT is segmented
cat("\nPELT segments:", nrow(result_pelt$segments), "\n")
cat("Heartwood segments: None (continuous)\n")
```

### When Heartwood is Not Available

If inner sensor is not deep enough:

```{r heartwood-fallback, eval=FALSE}
if (!heartwood_check$available) {
  cat("Heartwood reference not available\n")
  cat("Reason:", heartwood_check$reason, "\n\n")

  cat("Options:\n")
  cat("1. Verify sapwood depth measurement is correct\n")
  cat("2. Use PELT, manual, or VPD method instead\n")
  cat("3. If sapwood depth overestimated, update:\n")
  cat("   wood$sapwood_depth_cm <- [corrected_value]\n")

  # Fall back to PELT
  result <- apply_spacing_correction(
    vh_data = vh_results,
    method = "pelt",
    wood_properties = wood
  )
}
```

## Comprehensive Method Comparison

This section demonstrates how to compare all methods systematically to select the best approach for your data.

### Running All Methods

```{r compare-all, eval=FALSE}
# Store all results
results <- list()

# Method 1: No correction (baseline)
results$uncorrected <- list(
  name = "Uncorrected",
  data = vh_results
)

# Method 2: PELT
results$pelt <- list(
  name = "PELT (MBIC)",
  result = apply_spacing_correction(
    vh_data = vh_results,
    method = "pelt",
    wood_properties = wood,
    penalty = "MBIC",
    verbose = FALSE
  )
)
results$pelt$data <- results$pelt$result$vh_corrected

# Method 3: Manual (using PELT dates as example)
if (length(results$pelt$result$changepoints) > 0) {
  manual_dates <- as.character(results$pelt$result$changepoints)
  results$manual <- list(
    name = "Manual",
    result = apply_spacing_correction(
      vh_data = vh_results,
      method = "manual",
      wood_properties = wood,
      manual_changepoints = manual_dates,
      verbose = FALSE
    )
  )
  results$manual$data <- results$manual$result$vh_corrected
}

# Method 4: VPD (if weather data available)
if (exists("weather") && !is.null(weather)) {
  results$vpd <- list(
    name = "VPD (0.5 kPa)",
    result = apply_spacing_correction(
      vh_data = vh_results,
      method = "vpd",
      wood_properties = wood,
      weather_data = weather,
      vpd_threshold = 0.5,
      verbose = FALSE
    )
  )
  results$vpd$data <- results$vpd$result$vh_corrected
}

# Method 5: Heartwood (if available)
heartwood_check <- check_heartwood_reference_available(
  vh_data = vh_results,
  wood_properties = wood,
  probe_config = probe
)

if (heartwood_check$available) {
  results$heartwood <- list(
    name = "Heartwood",
    result = apply_spacing_correction(
      vh_data = vh_results,
      method = "heartwood",
      wood_properties = wood,
      probe_config = probe,
      verbose = FALSE
    )
  )
  results$heartwood$data <- results$heartwood$result$vh_corrected
}
```

### Quantitative Comparison

```{r compare-quantitative, eval=FALSE}
# Calculate summary statistics for each method
comparison_table <- data.frame(
  Method = character(),
  Mean_Vh = numeric(),
  SD_Vh = numeric(),
  Change_pct = numeric(),
  N_changepoints = integer(),
  stringsAsFactors = FALSE
)

# Baseline mean (uncorrected)
hrm_uncorrected <- results$uncorrected$data[
  results$uncorrected$data$method == "HRM" &
  results$uncorrected$data$sensor_position == "outer", ]
mean_uncorrected <- mean(hrm_uncorrected$Vh_cm_hr, na.rm = TRUE)

# Compare each method
for (method_name in names(results)) {
  method_data <- results[[method_name]]$data
  hrm_outer <- method_data[method_data$method == "HRM" &
                           method_data$sensor_position == "outer", ]

  mean_vh <- mean(hrm_outer$Vh_cm_hr, na.rm = TRUE)
  sd_vh <- sd(hrm_outer$Vh_cm_hr, na.rm = TRUE)
  change_pct <- ((mean_vh - mean_uncorrected) / mean_uncorrected) * 100

  # Get number of changepoints
  n_cpt <- if (method_name == "uncorrected") {
    0
  } else if (!is.null(results[[method_name]]$result$changepoints)) {
    length(results[[method_name]]$result$changepoints)
  } else {
    NA  # Heartwood has no changepoints
  }

  comparison_table <- rbind(comparison_table, data.frame(
    Method = results[[method_name]]$name,
    Mean_Vh = round(mean_vh, 4),
    SD_Vh = round(sd_vh, 4),
    Change_pct = round(change_pct, 2),
    N_changepoints = n_cpt,
    stringsAsFactors = FALSE
  ))
}

print(comparison_table)
```

### Visual Comparison

```{r compare-visual, eval=FALSE}
# Plot timeseries for each method
library(ggplot2)

# Combine data for plotting
plot_data <- data.frame()
for (method_name in names(results)) {
  hrm_outer <- results[[method_name]]$data[
    results[[method_name]]$data$method == "HRM" &
    results[[method_name]]$data$sensor_position == "outer", ]
  hrm_outer$correction_method <- results[[method_name]]$name
  plot_data <- rbind(plot_data, hrm_outer)
}

# Create comparison plot
ggplot(plot_data, aes(x = datetime, y = Vh_cm_hr, colour = correction_method)) +
  geom_line(alpha = 0.6) +
  facet_wrap(~correction_method, ncol = 1) +
  labs(
    title = "Spacing Correction Method Comparison",
    x = "Date",
    y = "Heat Pulse Velocity (cm/hr)",
    colour = "Method"
  ) +
  theme_minimal() +
  theme(legend.position = "bottom")
```

## Decision Framework

Use this framework to select the most appropriate method for your analysis:

### 1. First-Time Analysis

**Start with PELT** for objective, reproducible changepoint detection:

```{r decision-first-time, eval=FALSE}
result <- apply_spacing_correction(
  vh_data = vh_results,
  method = "pelt",
  wood_properties = wood,
  penalty = "MBIC",
  min_segment_days = 7
)
```

### 2. Validating PELT Results

**Cross-check with VPD** to ensure changepoints align with environmental conditions:

```{r decision-validate, eval=FALSE}
result_pelt <- apply_spacing_correction(vh_data = vh_results, method = "pelt",
                                        wood_properties = wood)
result_vpd <- apply_spacing_correction(vh_data = vh_results, method = "vpd",
                                       wood_properties = wood, weather_data = weather)

# Check overlap
# If high overlap → both methods agree, high confidence
# If low overlap → investigate causes, consider manual refinement
```

### 3. Incorporating Field Knowledge

**Use manual specification** when you have independent evidence of spacing changes:

```{r decision-field-knowledge, eval=FALSE}
# Based on field observations, cambial growth measurements, etc.
result <- apply_spacing_correction(
  vh_data = vh_results,
  method = "manual",
  wood_properties = wood,
  manual_changepoints = c("2024-03-15", "2024-06-10", "2024-09-01")
)
```

### 4. Long-Term Monitoring

**Use heartwood reference** (if available) for continuous correction without segmentation:

```{r decision-long-term, eval=FALSE}
# Check availability
heartwood_check <- check_heartwood_reference_available(
  vh_data = vh_results,
  wood_properties = wood,
  probe_config = probe
)

if (heartwood_check$available) {
  result <- apply_spacing_correction(
    vh_data = vh_results,
    method = "heartwood",
    wood_properties = wood,
    probe_config = probe
  )
} else {
  # Fall back to PELT
  result <- apply_spacing_correction(
    vh_data = vh_results,
    method = "pelt",
    wood_properties = wood
  )
}
```

### 5. Publication and Reproducibility

For publications, document your method selection clearly:

```{r decision-publication, eval=FALSE}
# Recommended: PELT with sensitivity analysis
result_main <- apply_spacing_correction(
  vh_data = vh_results,
  method = "pelt",
  wood_properties = wood,
  penalty = "MBIC",
  min_segment_days = 7
)

# Sensitivity tests
result_sens1 <- apply_spacing_correction(
  vh_data = vh_results, method = "pelt", wood_properties = wood,
  penalty = "BIC"  # More conservative
)

result_sens2 <- apply_spacing_correction(
  vh_data = vh_results, method = "pelt", wood_properties = wood,
  min_segment_days = 3  # Shorter segments
)

# Report range of results from sensitivity tests
```

## Integration with Calibration Workflow

Spacing correction integrates seamlessly with method calibration and sDMA (Selectable Dual Method Approach):

```{r integration-calibration, eval=FALSE}
# Step 1: Calculate multiple methods
vh_results <- calc_heat_pulse_velocity(
  hp_raw,
  methods = c("HRM", "MHR", "HRMXb"),
  wood_properties = wood
)

# Step 2: Apply spacing correction (HRM only)
correction_result <- apply_spacing_correction(
  vh_data = vh_results,
  method = "pelt",
  hpv_method = "HRM",
  wood_properties = wood
)

# Step 3: Apply late calibration + sDMA
# Calibrates secondary methods to corrected HRM
late_result <- apply_late_calibration_sdma(
  vh_corrected = correction_result$vh_corrected,
  primary_method = "HRM",
  secondary_methods = c("MHR", "HRMXb"),
  sdma_methods = "MHR",
  sensor_position = "outer"
)

# Step 4: Convert to flux density
# All methods (HRM, MHR, HRMXb, sDMA:MHR) are spacing-corrected and calibrated
sfd_results <- calc_sap_flux_density(
  vh_data = late_result$vh_with_sdma,
  wood_properties = wood,
  probe_config = probe
)
```

## Troubleshooting

### Issue: "No changepoints detected"

**Possible causes:**
- Insufficient data (< 7 days)
- No clear baseline shifts
- Penalty too strict
- Data quality issues

**Solutions:**

```{r troubleshoot-no-cpt, eval=FALSE}
# Try less strict penalty
result <- apply_spacing_correction(
  vh_data = vh_results, method = "pelt", wood_properties = wood,
  penalty = "AIC"  # Instead of BIC/MBIC
)

# Reduce minimum segment length
result <- apply_spacing_correction(
  vh_data = vh_results, method = "pelt", wood_properties = wood,
  min_segment_days = 3  # Instead of 7
)

# Use manual method if you know dates
result <- apply_spacing_correction(
  vh_data = vh_results, method = "manual", wood_properties = wood,
  manual_changepoints = c("2024-04-01")
)
```

### Issue: "Too many changepoints detected"

**Solutions:**

```{r troubleshoot-too-many, eval=FALSE}
# Use stricter penalty
result <- apply_spacing_correction(
  vh_data = vh_results, method = "pelt", wood_properties = wood,
  penalty = "BIC"  # More conservative than MBIC
)

# Increase minimum segment length
result <- apply_spacing_correction(
  vh_data = vh_results, method = "pelt", wood_properties = wood,
  min_segment_days = 14  # Longer segments
)

# Try numeric penalty for fine control
result <- apply_spacing_correction(
  vh_data = vh_results, method = "pelt", wood_properties = wood,
  penalty = 100  # Higher number = fewer changepoints
)
```

### Issue: "Inner sensor not in heartwood"

**Solutions:**

```{r troubleshoot-heartwood, eval=FALSE}
# Verify depths
cat("Inner sensor depth:", probe$sensor_depths$inner_cm, "cm\n")
cat("Sapwood depth:", wood$sapwood_depth_cm, "cm\n")

# Option 1: Update sapwood depth if measurement was incorrect
wood$sapwood_depth_cm <- 2.0  # Corrected value

# Option 2: Use different method
result <- apply_spacing_correction(
  vh_data = vh_results,
  method = "pelt",  # Instead of heartwood
  wood_properties = wood
)
```

### Issue: VPD method returns unexpected results

**Solutions:**

```{r troubleshoot-vpd, eval=FALSE}
# Check VPD data quality
summary(weather$VPD_kPa)
plot(weather$datetime, weather$VPD_kPa, type = "l")

# Try different threshold
result <- apply_spacing_correction(
  vh_data = vh_results, method = "vpd", wood_properties = wood,
  weather_data = weather,
  vpd_threshold = 0.3  # More conservative
)

# Check for sufficient low-VPD periods
low_vpd_days <- sum(weather$VPD_kPa < 0.5, na.rm = TRUE)
cat("Days with VPD < 0.5 kPa:", low_vpd_days, "\n")
```

## Best Practices

### 1. Always visualise results

```{r best-practice-visualise, eval=FALSE}
plot_changepoints_interactive(
  daily_min = result$correction_info$daily_min,
  changepoints = result$changepoints,
  segments = result$segments
)

plot_vh_timeseries(result$vh_corrected, sensor_position = "outer")
```

### 2. Compare multiple methods

Don't rely on a single method. Compare PELT, VPD, and manual to assess robustness.

### 3. Document parameter choices

```{r best-practice-document, eval=FALSE}
# Save metadata for reproducibility
correction_metadata <- list(
  method = "pelt",
  penalty = "MBIC",
  min_segment_days = 7,
  thermal_diffusivity = wood$derived_properties$thermal_diffusivity_actual_cm2_s,
  date_applied = Sys.time(),
  package_version = packageVersion("sapfluxr")
)

saveRDS(correction_metadata, "correction_metadata.rds")
```

### 4. Perform sensitivity analysis

Test how results change with different parameters.

### 5. Cross-validate with environmental data

If possible, check that changepoints align with known environmental events (frost, drought, etc.).

## References

Burgess, S.S.O., Adams, M.A., Turner, N.C., Beverly, C.R., Ong, C.K., Khan, A.A.H. and Bleby, T.M. (2001). An improved heat pulse method to measure low and reverse rates of sap flow in woody plants. *Tree Physiology*, 21(9), 589-598.

Killick, R., Fearnhead, P. and Eckley, I.A. (2012). Optimal detection of changepoints with a linear computational cost. *Journal of the American Statistical Association*, 107(500), 1590-1598.

Wullschleger, S.D., Childs, K.W., King, A.W. and Hanson, P.J. (2011). A model of heat transfer in sapwood and implications for sap flux density measurements using thermal dissipation probes. *Tree Physiology*, 31(6), 669-679.

## See Also

- `detect_changepoints()` - PELT changepoint detection
- `detect_vpd_changepoints()` - VPD-based detection
- `apply_spacing_correction_both_sensors()` - Low-level correction function
- `check_heartwood_reference_available()` - Check heartwood availability
- `calculate_burgess_coefficients()` - Burgess correction coefficients
