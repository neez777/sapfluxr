# Generated by using Rcpp::compileAttributes() -> do not edit by hand
# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393

#' Fast Number Extraction from Text Records - C++ Implementation
#'
#' @description
#' Fast extraction of all numeric values from text records (JSON-like format).
#' Much faster than regex-based extraction in R, especially for large datasets.
#'
#' @param records Character vector of text records to parse
#' @param expected_numbers_per_record Integer, expected number of values per record
#'
#' @return Numeric matrix where each row contains numbers from one record
#'
#' @keywords internal
#' @export
extract_numbers_from_records_cpp <- function(records, expected_numbers_per_record) {
    .Call(`_sapfluxr_extract_numbers_from_records_cpp`, records, expected_numbers_per_record)
}

#' Parse ICT Current Format Records - C++ Implementation
#'
#' @description
#' Fast batch parsing of ICT current format records into diagnostics and measurements.
#' Replaces R loop that processes records one-by-one.
#'
#' @param records Character vector of pulse records (without leading delimiter)
#' @param pulse_times Numeric vector of pulse timestamps (as.numeric(POSIXct))
#' @param measurement_interval Integer, seconds between consecutive measurements
#' @param expected_diagnostics Integer, number of diagnostic values per pulse (default: 5)
#'
#' @return List containing:
#'   \item{diagnostics}{Data frame with diagnostic values for each pulse}
#'   \item{measurements}{Data frame with temperature measurements}
#'
#' @keywords internal
#' @export
parse_ict_records_cpp <- function(records, pulse_times, measurement_interval, expected_diagnostics = 5L) {
    .Call(`_sapfluxr_parse_ict_records_cpp`, records, pulse_times, measurement_interval, expected_diagnostics)
}

#' Fast Datetime Extraction from Text Records - C++ Implementation
#'
#' @description
#' Fast extraction of datetime strings from JSON-like records.
#' Looks for "date" field and extracts the value.
#'
#' @param records Character vector of text records
#'
#' @return Character vector of datetime strings
#'
#' @keywords internal
#' @export
extract_datetimes_cpp <- function(records) {
    .Call(`_sapfluxr_extract_datetimes_cpp`, records)
}

#' Calculate HRM (Heat Ratio Method) - C++ Implementation
#'
#' @param dTratio_douo Numeric vector of downstream/upstream temperature ratios (outer)
#' @param dTratio_diui Numeric vector of downstream/upstream temperature ratios (inner)
#' @param HRM_period Logical vector indicating HRM sampling window
#' @param tp Numeric vector of time after pulse (seconds)
#' @param diffusivity Thermal diffusivity (cm²/s)
#' @param probe_spacing Probe spacing (cm)
#'
#' @return List containing HRM results for outer and inner sensors
#'
#' @keywords internal
#' @export
calc_hrm_cpp <- function(dTratio_douo, dTratio_diui, HRM_period, tp, diffusivity, probe_spacing) {
    .Call(`_sapfluxr_calc_hrm_cpp`, dTratio_douo, dTratio_diui, HRM_period, tp, diffusivity, probe_spacing)
}

#' Calculate MHR (Maximum Heat Ratio) - C++ Implementation
#'
#' @param deltaT_do Numeric vector of delta temperatures (downstream outer)
#' @param deltaT_di Numeric vector of delta temperatures (downstream inner)
#' @param deltaT_uo Numeric vector of delta temperatures (upstream outer)
#' @param deltaT_ui Numeric vector of delta temperatures (upstream inner)
#' @param diffusivity Thermal diffusivity (cm²/s)
#' @param probe_spacing Probe spacing (cm)
#' @param pre_pulse Pre-pulse period (seconds)
#'
#' @return List containing MHR results for outer and inner sensors
#'
#' @keywords internal
#' @export
calc_mhr_cpp <- function(deltaT_do, deltaT_di, deltaT_uo, deltaT_ui, diffusivity, probe_spacing, pre_pulse) {
    .Call(`_sapfluxr_calc_mhr_cpp`, deltaT_do, deltaT_di, deltaT_uo, deltaT_ui, diffusivity, probe_spacing, pre_pulse)
}

#' Preprocess Pulse Data - C++ Implementation
#'
#' @description
#' Fast preprocessing of temperature data for a single pulse.
#' Calculates delta temperatures, ratios, and peak information in one pass.
#'
#' @param do_vec Numeric vector of downstream outer temperatures
#' @param di_vec Numeric vector of downstream inner temperatures
#' @param uo_vec Numeric vector of upstream outer temperatures
#' @param ui_vec Numeric vector of upstream inner temperatures
#' @param pre_pulse Integer, number of pre-pulse measurements
#'
#' @return List containing delta temps, ratios, and peak info
#'
#' @keywords internal
#' @export
preprocess_pulse_data_cpp <- function(do_vec, di_vec, uo_vec, ui_vec, pre_pulse) {
    .Call(`_sapfluxr_preprocess_pulse_data_cpp`, do_vec, di_vec, uo_vec, ui_vec, pre_pulse)
}

#' Calculate Tmax Cohen - C++ Implementation
#'
#' @param deltaT_do Numeric vector of delta temperatures (downstream outer)
#' @param deltaT_di Numeric vector of delta temperatures (downstream inner)
#' @param diffusivity Thermal diffusivity (cm²/s)
#' @param probe_spacing Probe spacing (cm)
#' @param pre_pulse Pre-pulse period (seconds)
#'
#' @return List containing Tmax_Coh results
#'
#' @keywords internal
#' @export
calc_tmax_coh_cpp <- function(deltaT_do, deltaT_di, diffusivity, probe_spacing, pre_pulse) {
    .Call(`_sapfluxr_calc_tmax_coh_cpp`, deltaT_do, deltaT_di, diffusivity, probe_spacing, pre_pulse)
}

#' Calculate Tmax Kluitenberg - C++ Implementation
#'
#' @param deltaT_do Numeric vector of delta temperatures (downstream outer)
#' @param deltaT_di Numeric vector of delta temperatures (downstream inner)
#' @param diffusivity Thermal diffusivity (cm²/s)
#' @param probe_spacing Probe spacing (cm)
#' @param tp_1 Heat pulse duration (seconds)
#' @param pre_pulse Pre-pulse period (seconds)
#'
#' @return List containing Tmax_Klu results
#'
#' @keywords internal
#' @export
calc_tmax_klu_cpp <- function(deltaT_do, deltaT_di, diffusivity, probe_spacing, tp_1, pre_pulse) {
    .Call(`_sapfluxr_calc_tmax_klu_cpp`, deltaT_do, deltaT_di, diffusivity, probe_spacing, tp_1, pre_pulse)
}

#' Calculate HRMX (Modified Heat Ratio) - C++ Implementation
#'
#' @param deltaT_do Numeric vector of delta temperatures (downstream outer)
#' @param deltaT_di Numeric vector of delta temperatures (downstream inner)
#' @param deltaT_uo Numeric vector of delta temperatures (upstream outer)
#' @param deltaT_ui Numeric vector of delta temperatures (upstream inner)
#' @param dTratio_douo Numeric vector of temperature ratios (do/uo)
#' @param dTratio_diui Numeric vector of temperature ratios (di/ui)
#' @param tp Numeric vector of time after pulse (seconds)
#' @param L Lower proportion of deltaTmax for sampling window
#' @param H Higher proportion of deltaTmax for sampling window
#' @param diffusivity Thermal diffusivity (cm²/s)
#' @param probe_spacing Probe spacing (cm)
#' @param idx_do_max Index of max for downstream outer (1-based from R)
#' @param idx_di_max Index of max for downstream inner (1-based from R)
#' @param idx_uo_max Index of max for upstream outer (1-based from R)
#' @param idx_ui_max Index of max for upstream inner (1-based from R)
#' @param dTdo_max Maximum value for downstream outer
#' @param dTdi_max Maximum value for downstream inner
#' @param dTuo_max Maximum value for upstream outer
#' @param dTui_max Maximum value for upstream inner
#'
#' @return List containing HRMXa and HRMXb results
#'
#' @keywords internal
#' @export
calc_hrmx_cpp <- function(deltaT_do, deltaT_di, deltaT_uo, deltaT_ui, dTratio_douo, dTratio_diui, tp, L, H, diffusivity, probe_spacing, idx_do_max, idx_di_max, idx_uo_max, idx_ui_max, dTdo_max, dTdi_max, dTuo_max, dTui_max) {
    .Call(`_sapfluxr_calc_hrmx_cpp`, deltaT_do, deltaT_di, deltaT_uo, deltaT_ui, dTratio_douo, dTratio_diui, tp, L, H, diffusivity, probe_spacing, idx_do_max, idx_di_max, idx_uo_max, idx_ui_max, dTdo_max, dTdi_max, dTuo_max, dTui_max)
}

#' Detect Outliers Using Rolling Mean (C++ Implementation)
#'
#' @description
#' Fast C++ implementation of rolling mean outlier detection.
#' Identifies points that deviate significantly from their local rolling mean.
#'
#' @param vh_values Numeric vector of Vh values
#' @param window Integer, half-width of rolling window (default: 5, meaning 11-point window)
#' @param threshold Numeric, standard deviation multiplier (default: 3 = 99.7% confidence)
#'
#' @return Integer vector of outlier indices (1-based for R compatibility)
#'
#' @details
#' For each point i, calculates mean and SD of window [(i-window):(i+window)].
#' Points deviating by more than threshold × SD from the local mean are flagged.
#'
#' **Performance:** O(n × window) but with fast C++ loops and minimal overhead.
#' Typically 10-50x faster than pure R implementation for large datasets.
#'
#' @keywords internal
#' @export
detect_outliers_rolling_mean_cpp <- function(vh_values, window = 5L, threshold = 3.0) {
    .Call(`_sapfluxr_detect_outliers_rolling_mean_cpp`, vh_values, window, threshold)
}

#' Detect Rate of Change Outliers (C++ Implementation)
#'
#' @description
#' Fast C++ implementation of rate of change outlier detection.
#' Identifies consecutive measurements that change by more than the specified threshold.
#'
#' @param vh_values Numeric vector of Vh values (must be sorted by time)
#' @param max_change Numeric, maximum allowed change between consecutive points (cm/hr)
#'
#' @return Integer vector of outlier indices (1-based, returns the second point in each pair)
#'
#' @details
#' Sap flow typically changes gradually. Large jumps (e.g., > 4 cm/hr between
#' 30-min intervals) are likely sensor errors or logging issues.
#'
#' **Performance:** O(n) with fast C++ loops.
#' Typically 20-100x faster than pure R implementation.
#'
#' @keywords internal
#' @export
detect_rate_of_change_outliers_cpp <- function(vh_values, max_change = 4.0) {
    .Call(`_sapfluxr_detect_rate_of_change_outliers_cpp`, vh_values, max_change)
}

#' Identify Gaps in Time Series - C++ Implementation
#'
#' @description
#' Fast gap detection that identifies consecutive NA values and calculates gap durations.
#' Much faster than R version, especially for large datasets.
#'
#' @param datetimes Numeric vector of timestamps (as.numeric(POSIXct))
#' @param vh_values Numeric vector of velocities (may contain NA)
#' @param is_na Logical vector indicating which values are NA (pre-computed for efficiency)
#'
#' @return List containing gap information:
#'   \item{start_idx}{Integer vector of gap start indices (1-based)}
#'   \item{end_idx}{Integer vector of gap end indices (1-based)}
#'   \item{n_missing}{Integer vector of number of missing points per gap}
#'   \item{duration_hours}{Numeric vector of gap durations in hours}
#'
#' @keywords internal
#' @export
identify_gaps_cpp <- function(datetimes, vh_values, is_na) {
    .Call(`_sapfluxr_identify_gaps_cpp`, datetimes, vh_values, is_na)
}

#' Linear Interpolation - C++ Implementation
#'
#' @description
#' Fast linear interpolation between valid points. Much faster than R's approx()
#' for large datasets.
#'
#' @param vh_values Numeric vector of velocities (with NAs to fill)
#' @param datetimes Numeric vector of timestamps
#' @param gap_start Integer, start index of gap (1-based)
#' @param gap_end Integer, end index of gap (1-based)
#'
#' @return Numeric vector of interpolated values for the gap
#'
#' @keywords internal
#' @export
interpolate_linear_cpp <- function(vh_values, datetimes, gap_start, gap_end) {
    .Call(`_sapfluxr_interpolate_linear_cpp`, vh_values, datetimes, gap_start, gap_end)
}

#' Weighted Average Interpolation - C++ Implementation
#'
#' @description
#' Fast inverse-distance weighted interpolation. Uses surrounding valid points
#' with weights inversely proportional to temporal distance.
#'
#' @param vh_values Numeric vector of velocities
#' @param datetimes Numeric vector of timestamps
#' @param gap_start Integer, start index of gap (1-based)
#' @param gap_end Integer, end index of gap (1-based)
#' @param window_size Integer, number of points to consider on each side of gap
#'
#' @return Numeric vector of interpolated values for the gap
#'
#' @keywords internal
#' @export
interpolate_weighted_cpp <- function(vh_values, datetimes, gap_start, gap_end, window_size) {
    .Call(`_sapfluxr_interpolate_weighted_cpp`, vh_values, datetimes, gap_start, gap_end, window_size)
}

#' Fast Gap Interpolation for Entire Dataset - C++ Implementation
#'
#' @description
#' Optimized function that interpolates all gaps in a dataset in one pass.
#' Much faster than looping through gaps in R.
#'
#' @param vh_values Numeric vector of velocities (with NAs to fill)
#' @param datetimes Numeric vector of timestamps
#' @param gap_starts Integer vector of gap start indices (1-based)
#' @param gap_ends Integer vector of gap end indices (1-based)
#' @param gap_durations Numeric vector of gap durations in hours
#' @param max_gap_hours Numeric, maximum gap duration to interpolate
#' @param method Character, interpolation method: "linear" or "weighted"
#' @param window_size Integer, window size for weighted interpolation
#'
#' @return List containing:
#'   \item{vh_values}{Numeric vector with gaps filled}
#'   \item{interpolated_indices}{Integer vector of indices that were interpolated (1-based)}
#'   \item{large_gap_indices}{Integer vector of indices of gaps too large to fill (1-based)}
#'
#' @keywords internal
#' @export
interpolate_all_gaps_cpp <- function(vh_values, datetimes, gap_starts, gap_ends, gap_durations, max_gap_hours, method = "linear", window_size = 5L) {
    .Call(`_sapfluxr_interpolate_all_gaps_cpp`, vh_values, datetimes, gap_starts, gap_ends, gap_durations, max_gap_hours, method, window_size)
}

#' Smart Pre-filter for Flagged Rows - C++ Implementation
#'
#' @description
#' Efficiently identifies rows that need interpolation based on quality flags.
#' Returns indices grouped by method/sensor for efficient processing.
#'
#' @param quality_flags Character vector of quality flags
#' @param flags_to_interpolate Character vector of flags that should be interpolated
#' @param method_col Character vector of method names (optional)
#' @param sensor_col Character vector of sensor positions (optional)
#'
#' @return List containing:
#'   \item{flagged_indices}{Integer vector of all flagged row indices (1-based)}
#'   \item{n_flagged}{Number of flagged rows}
#'   \item{prop_flagged}{Proportion of data that's flagged}
#'
#' @keywords internal
#' @export
prefilter_flagged_rows_cpp <- function(quality_flags, flags_to_interpolate, method_col = NULL, sensor_col = NULL) {
    .Call(`_sapfluxr_prefilter_flagged_rows_cpp`, quality_flags, flags_to_interpolate, method_col, sensor_col)
}

